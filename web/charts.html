<!doctype html>
<html>

<head>
    <title>Charts</title>
    <script src="scripts/moment.min.js"></script>
    <script src="scripts/Chart.min.js"></script>
    <link href="style.css" rel="stylesheet">
    <script src="script.js"></script>
</head>

<body>
    <div class="header">
        <!-- //TODO: put more stuff into the header: value count, uptime-->
        <h1>Hardware Statistics</h1>
        <input type="button" value="Update" class="updateButton" title="Updates all charts without reloading the page" onclick="refillCharts();">
        
        <!--//TODO: stuff-->
        <div id="autoUpdateDiv" class="autoUpdateDiv" style="display: none;">
            <label title="Check to automatically update the charts">
                <input type="checkbox" class="autoUpdateCheckbox" onclick="console.log('click')">Auto update every
            </label>
            <input type="number" value="10" style="width: 40px" class="autoUpdateRate" onclick="console.log('What?')">
            <select onchange="console.log('hi')">
                <option value="seconds">Seconds</option>
                <option value="minutes" selected="selected">Minutes</option>
            </select>
        </div>
    </div>

    <div id="contentDiv" class="content">
        <!--will be filled with generated content-->
    </div>

    <script>
        var dataSource = {
            values: [],
            byteToGB: function (bytes) {
                return bytes / 1024 / 1024 / 1024;
            },
            getValues: function () {
                if (this.values.length > 0) {
                    return this.values;
                }
                var xhttp = new XMLHttpRequest();
                xhttp.onreadystatechange = function () {
                    if (this.readyState == 4 && this.status == 200) {
                        dataSource.values = JSON.parse(this.responseText);
                    }
                };
                xhttp.open("GET", "/getdata", false);
                xhttp.send();
                return this.values;
            },
            getRAMUsage: function () {
                var ret = [];
                var values = this.getValues();
                for (var i = 0; i < values.length; i++) {
                    var obj = values[i];
                    var unixTime = moment(obj.timestamp, "YYYY-MM-DD HH:mm:ss").valueOf();
                    ret.push({ t: unixTime, y: obj.ram.used / 1024 / 1024 / 1024 });
                }
                return ret;
            },
            getRAMData: function () {
                var ret = {};
                var objArr = this.getValues();
                var current = objArr[objArr.length - 1];
                ret.data = [current.ram.free / 1024 / 1024 / 1024, current.ram.used / 1024 / 1024 / 1024];
                ret.max = current.ram.total / 1024 / 1024 / 1024;
                return ret;
            },
            getCPUData: function () {
                var ret = [];
                var objArr = this.getValues();
                for (var i = 0; i < objArr.length; i++) {
                    var obj = objArr[i];
                    var unixTime = moment(obj.timestamp, "YYYY-MM-DD HH:mm:ss").valueOf();
                    ret.push({ t: unixTime, y: obj.cpu.utilization });
                }
                return ret;
            },
            getPartitionUsage: function (index) {
                var ret = [];
                var objArr = this.getValues();
                for (var i = 0; i < objArr.length; i++) {
                    var obj = objArr[i];
                    var unixTime = moment(obj.timestamp, "YYYY-MM-DD HH:mm:ss").valueOf();
                    ret.push({ t: unixTime, y: this.byteToGB(obj.partitions[index].used) });
                }
                return ret;
            },
            getPartitionData: function (index) {
                var ret = {};
                var objArr = this.getValues();
                var current = objArr[objArr.length - 1];
                ret.data = [current.partitions[index].free / 1024 / 1024 / 1024, current.partitions[index].used / 1024 / 1024 / 1024];
                ret.max = current.partitions[index].total / 1024 / 1024 / 1024;
                return ret;
            },
            getPartitionCount: function () {
                var objArr = this.getValues();
                return objArr[objArr.length - 1].partitions.length;
            },
            getPartitionName: function (index) {
                var objArr = this.getValues();
                return objArr[objArr.length - 1].partitions[index].name;
            },
            getDownload: function () {
                var ret = [];
                var values = this.getValues();
                for (var i = 0; i < values.length; i++) {
                    var obj = values[i];
                    var unixTime = moment(obj.timestamp, "YYYY-MM-DD HH:mm:ss").valueOf();
                    ret.push({ t: unixTime, y: obj.network.recv / 1024 / 1024 / 1024 });
                }
                return ret;
            },
            getUpload: function () {
                var ret = [];
                var values = this.getValues();
                for (var i = 0; i < values.length; i++) {
                    var obj = values[i];
                    var unixTime = moment(obj.timestamp, "YYYY-MM-DD HH:mm:ss").valueOf();
                    ret.push({ t: unixTime, y: obj.network.sent / 1024 / 1024 / 1024 });
                }
                return ret;
            },
            getProcesses: function () {
                var ret = [];
                var values = this.getValues();
                for (var i = 0; i < values.length; i++) {
                    var obj = values[i];
                    var unixTime = moment(obj.timestamp, "YYYY-MM-DD HH:mm:ss").valueOf();
                    ret.push({ t: unixTime, y: obj.system.processes });
                }
                return ret;
            },
            getUptime: function () {
                var objArr = this.getValues();
                return objArr[objArr.length - 1].system.uptime;
            },
            getValueCount: function () {
                return this.getValues().length;
            },
            clearCache: function () {
                //this.getValues() will request new values on next call
                this.values = [];
            }
        }

        insertHeadline("RAM");
        var ramDiv = createDiv("ram");
        var ramData = dataSource.getRAMData();
        var ramChart = generateChart(createChartWrapper("ramChart", "all lineChartX", ramDiv), "RAM usage", "RAM in GB", "GB", dataSource.getRAMUsage(), { min: 0, max: ramData.max, step: 1 });
        var ramPieChart = generatePieChart(createChartWrapper("ramPirChart", "all pieChart", ramDiv), "RAM usage", "RAM in GB", "GB", ["Free", "Used"], ["green", "orange"], ramData.data, ramData.max);

        insertHeadline("CPU");
        var cpuDiv = createDiv("cpu");
        var cpuChart = generateChart(createChartWrapper("cpuChart", "all lineChart", cpuDiv), "CPU usage", "CPU in %", "%", dataSource.getCPUData(), { min: 0, max: 100, step: 10 });

        var partCharts = [];
        var partPieCharts = [];
        for (var i = 0; i < dataSource.getPartitionCount(); i++) {
            insertHeadline("Disk " + dataSource.getPartitionName(i));
            var partitionDiv = createDiv("partition" + i);
            var pData = dataSource.getPartitionData(i);
            var partChart = generateChart(createChartWrapper("partitionChart" + i, "all lineChartX", partitionDiv), "Memory usage", "Memory in GB", "GB", dataSource.getPartitionUsage(i), { min: 0, max: pData.max, step: 50 });
            partCharts.push(partChart);
            var partPieChart = generatePieChart(createChartWrapper("partitionPieChart" + i, "all pieChart", partitionDiv), "Memory usage", "Memory in GB", "GB", ["Free", "Used"], ["green", "red"], pData.data, pData.max);
            partPieCharts.push(partPieChart);
        }

        insertHeadline("Network");
        var dlDiv = createDiv("download");
        var dlChart = generateChart(createChartWrapper("downloadChart", "all lineChart", dlDiv), "Downloaded data", "Data in GB", "GB", dataSource.getDownload(), { min: 0, max: 0, step: 0.5 });
        var ulDiv = createDiv("upload");
        var ulChart = generateChart(createChartWrapper("uploadChart", "all lineChart", ulDiv), "Uploaded data", "Data in GB", "GB", dataSource.getUpload(), { min: 0, max: 0, step: 0.1 });

        insertHeadline("Processes");
        var procDiv = createDiv("processes");
        var procChart = generateChart(createChartWrapper("processesChart", "all lineChart", procDiv), "Processes", "Total processes running", "", dataSource.getProcesses(), { min: 0, max: 0, step: 10 });

        insertHeadline("Other");
        createDataHolder("uptime", "Uptime: " + formatTimeDuration(dataSource.getUptime()));
        createDataHolder("values", "Values: " + dataSource.getValueCount());

        function refillCharts() {
            dataSource.clearCache();
            setChartData(this.ramChart, dataSource.getRAMUsage());
            setChartData(this.ramPieChart, dataSource.getRAMData().data);
            setChartData(this.cpuChart, dataSource.getCPUData());

            var parts = partCharts.length;
            for (var i = 0; i < parts; i++) {
                setChartData(partCharts[i], dataSource.getPartitionUsage(i));
                setChartData(partPieCharts[i], dataSource.getPartitionData(i).data);
            }

            setChartData(this.dlChart, dataSource.getDownload());
            setChartData(this.ulChart, dataSource.getUpload());
            setChartData(this.procChart, dataSource.getProcesses());

            createDataHolder("uptime", "Uptime: " + formatTimeDuration(dataSource.getUptime()));
            createDataHolder("values", "Values: " + dataSource.getValueCount());
        }

        function setChartData(chart, data) {
            chart.data.datasets[0].data = data;
            chart.update();
        }
    </script>
</body>

</html>